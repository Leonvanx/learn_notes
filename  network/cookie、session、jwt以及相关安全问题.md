HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：***每次请求都是独立的***，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。

1. Cookie：服务端发送给客户端，并在**客户端存储**的一小块特殊数据，客户端每次向服务器端发送请求时都会带上这些数据。Cookie是**不可跨域**的，无法在别的域名下使用。Cookie相当于由用户自己保存的一张纸，上面记载着用户的信息。比如用户名、密码等等。Cookie一般是由浏览器在后台自动发送给服务器的。浏览器会检查所有的Cookie，当某个Cookie的作用域大于或等于所要访问的资源的位置时，浏览器就会把这个Cookie附在请求资源的HTTP请求头上发送给服务器。可以说，这种方式是客户端（用户）在维持状态。 

2. Session：Session基于Cookie实现，但是相关数据**存储于服务端**，服务端会在第一次请求认证成功后返回给客户端一个SessionID，被存储到客户端的Cookie中。形象的来说，一个Session相当于是一张会员卡，上面除了一个卡号其他什么都没有。这个卡号就是Session ID。当存在Session ID时就检索出相应的Session。不存在则创建一个Session并生成一个Session ID。Session ID的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。当一个用户拿着这张“会员卡”访问一个网站时，用户在网站上的有关信息和操作都会被记录在服务端的这张会员卡对应的卡号下。很明显，这种方式就是服务端在维持状态。而Session机制和Cookie机制又有什么联系呢？虽然Session机制中用户的状态由服务端来维持，但是，Session中的Session ID还是要用户自己来保管的，而一般来说，Session ID则以Cookie的形式保存在客户端。但这种方式有一个弊端就是如果客户端禁用了Cookie，那么Session机制将无法正常工作。解决这个问题有两种方法，一种是URL重写，简单的说就是将Session ID作为URL的附加信息或参数，通过URL来传递。另一种是将Session ID写在表单（Form）的隐藏域中，在表单提交时将Session ID一起提交上去。

3. JWT：是一个开放标准协议，它定义了一种“紧凑”和“自包含”的方式，它用于各方之间作为JSON对象安全地传输信息。

   > **紧凑：**数据量较少，并且能通过url参数，http请求提交的数据以及http [header](https://so.csdn.net/so/search?q=header&spm=1001.2101.3001.7020)的方式来传递。
   >
   > **自包含：**这个串可以包含很多信息，比如用户ID，订单号ID等，如果被其他人拿到该信息，也就可以拿到关键业务信息。

   > [更多关于Cookie，Session的介绍](https://mp.weixin.qq.com/s/aID_N9bgq91EM26qVSVBXw)

## session 认证流程：

1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

## Cookie和Session的区别：

1. 安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
2. 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
3. 有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
4. 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

## Cookie + Session 存在的问题

虽然我们使用 Cookie + Session 的方式完成了登录验证，但仍然存在一些问题：

- 由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器压力过大。
- 如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，无形中增加了服务器端维护成本。
- 由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击。

## 以下是使用 JSON Web Token 的一些场景：

**授权**：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，从而允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小并且能够在不同的域中轻松使用。

**信息交换**：JSON Web Token 是在各方之间安全传输信息的好方法。因为可以对 JWT 进行签名（例如，使用公钥/私钥对），所以您可以确定发件人就是他们所说的那个人。此外，由于使用标头和有效负载计算签名，还可以验证内容没有被篡改。

## CSRF和XSS攻击

1. **XSS**：构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 攻击者获取受害者的Cookie → 攻击者使用受害者的Cookie去干坏事 → 攻击完成
2. **CSRF**：构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 受害者执行了恶意代码 → 攻击完成 

可以发现，XSS是攻击者获取到了受害者的Cookie，自己去执行恶意代码操作，而CSRF则是受害者在打开攻击者的代码时，攻击就已经完成了，攻击者只需构造代码并诱使受害者打开，一次CSRF攻击就完成了。简单的说，XSS是盗取Cookie，CSRF是盗用Session。 

完成一次完整的CSRF攻击需要两个条件：

1. 用户登录可信站点A，并在本地存储了A的Cookie；

2. 用户在不登出A的情况下，访问B；